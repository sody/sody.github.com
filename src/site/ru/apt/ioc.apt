 ----
 Инверсия управления
 ----
 Мартин Фоулер
 ----
 2005-06-26

Инверсия управления

  Инверсия управления является распостраненным явлением, с которым вы столкнетесь при использовании фреймворков. И действительно,
  она часто рассматривается как определяющая характеристика фреймворка.

  Давайте рассмотрим простой пример. Представьте себе что я пишу программу, которая получает некоторую информацию от пользователя
  с помощью командной строки. Я мог бы сделать это как-то так:

+----+
  #ruby
  puts 'What is your name?'
  name = gets
  process_name(name)
  puts 'What is your quest?'
  quest = gets
  process_quest(quest)
+----+

  В этой ситуации мой код управляет исполнением: он решает, когда задавать вопросы, когда считывать ответы, а когда обрабатывать
  результаты.

  Однако, если бы я использовал оконную систему для чего-то похожего, я написал бы что-то, что работает с окном:

+----+
  require 'tk'
  root = TkRoot.new()
  name_label = TkLabel.new() {text "What is Your Name?"}
  name_label.pack
  name = TkEntry.new(root).pack
  name.bind("FocusOut") {process_name(name)}
  quest_label = TkLabel.new() {text "What is Your Quest?"}
  quest_label.pack
  quest = TkEntry.new(root).pack
  quest.bind("FocusOut") {process_quest(quest)}
  Tk.mainloop()
+----+

  Теперь между этими двумя программами большая разница в потоке управления - в частности, в управлении временем когда вызываются
  методы <<<process_name>>> и <<<process_quest>>>. В примере с коммандной строкой я контролирую, когда эти методы вызываются, но в
  примере с оконным приложением нет. Вместо этого я передаю контроль оконной системе (команда <<<Tk.mainloop>>>). Далее она решает
  когда вызвать мои методы, основываясь на связях, которые я настроил при создании формы. Управление инвертировано - управляют
  мной, а не я управляю фреймворком. Это явление и называется инверсией управления (также известно как Принцип Голливуда -
  "Не звони нам, мы сами позвоним тебе" - <Hollywood Principle - "Don't call us, we'll call you">).

  <Одной важной характеристикой фреймворка является то, что методы, определенные пользователем для адаптации фреймворка под свои
  нужды, будут чаще всего вызываться внутри самого же фреймворка, а не из кода приложения пользователя. Фреймворк часто играет
  роль главной программы в координации и последовательности действий приложения. Такая инверсия управления дает фреймворку
  возможность служить расширяемым скелетом приложения. Методы, предоставляемые пользователем, адаптируют общие алгоритмы,
  определенные фреймворком, под определенное приложение.>
  <--Ральф Джонсон и Брайан Фут>

  Инверсия управления является ключевой частью того, что различает фреймворк и библиотеку. Библиотека это по существу набор
  функций, которые вы можете вызывать, в наши дни они организованы в классы. Каждый вызов выполняет некоторую работу и возвращает
  управление обратно пользователю.

  Фреймворк воплощает в себе некоторый абстрактный дизайн со встроенным поведением. Для того, чтобы использовать его, вы должны
  добавить свой код в различных местах фреймворка, либо через наследование, либо подключив свой собственный класс. Код
  фреймворка впоследствие будет вызывать ваш код.

  Существуют различные способы подключить ваш код для его дальнейшего вызова. В предыдущем примере на ruby, мы вызываем метод
  <<<bind>>> текстового поля, который принимает имя события и {{{http://martinfowler.com/bliki/Closure.html}замыкание}} в качестве
  аргументов. Всякий раз, когда текстовое поле узнает о событии, оно вызывает наш код из замыкания. Использование таких замыканий
  очень удобно, но многие языки не поддерживают их.

  Еще один способ сделать это - сделать так, чтобы фреймворк определил события, а код пользователя подписался на эти события. .NET
  является хорошим примером платформы, которая позволяет людям объявлять свои события на виджеты средствами языка. Вы можете
  назначить метод для события с помощью делегатов.

  Рассмотренные выше подходы (они одинаковые) хорошо подходят в единичных случаях, но иногда вам может понадобиться объединить
  некоторое количество вызовов в единый блок расширения. В этом случае фреймворк может определить интерфейс, который ваш код
  должен будет реализовать для соответствующих вызовов.

  EJB-компоненты являются хорошим примером такого стиля инверсии управления. При разработке сессионного компонента(session bean),
  вы можете реализовать различные методы, которые вызываются EJB-контейнером в различных точках/состояниях жизненного цикла.
  Например у интерфейса <<<SessionBean>>> есть методы <<<ejbRemove>>>, <<<ejbPassivate>>> (сохранен во вторичное хранилище) и
  <<<ejbActivate>>> (восстановлен из пассивного состояния). Вы не можете управлять вызовом этих методов, только тем, что они
  делают. Контейнер вызывает нас, а не мы вызываем его.

  Это сложные случаи инверсии управления, но вы столкнетесь с этим в гораздо более простых ситуациях. Шаблонный метод является
  хорошим примером: супер-класс определяет поток управления, субклассы наследуются от него переопределяя методы или реализуя
  абстрактные методы. Например, в JUnit, код фреймворка вызывает методы <<<setUp>>> и <<<tearDown>>> для вас, чтобы создавать и
  очищать ваш тест. Происходит вызов, ваш код реагирует - это снова инверсия управления.

  В наши дни, в связи с ростом количества IoC-контейнеров, существует некоторая путаница со смыслом инверсии управления. Некоторые
  люди путают общий принцип с конкретными стилями инверсии управления (такими как
  {{{http://martinfowler.com/articles/injection.html} внедрение зависимостей}}), которые эти контейнеры используют. Название
  немного запутанно (и иронично), так как IoC-контейнеры, как правило, рассматриваются в качестве конкурента EJB, но EJB
  использует инверсию управления.

  <<Этимология>>: Насколько я могу судить, термин инверсии управления впервые появился на свет в работе Джонсона и Фута
  {{{http://www.laputan.org/drc/drc.html}Designing Reusable Classes}}, опубликованной в журнале Object-Oriented Programming
  в 1988 году. Работа является одной из тех, что в возрасте хороши - ее можно прочитать даже спустя пятнадцать лет. Они считают,
  что они взяли этот термин откуда-то еще, но не могут вспомнить откуда. Затем термин втерся в объектно-ориентированное сообщество
  и вновь появился в книге Gang of Four. Более красивый синоним "Принцип Голливуда", кажется, берет начало в
  {{{http://www.digibarn.com/friends/curbow/star/XDEPaper.pdf} работе Ричарда Свита}} в Mesa в 1983 году. В списке целей
  разработки он пишет: <Не звони нам, мы сами позвоним тебе (Закон Голливуда): инструмент должен организовать Тахо, чтобы
  предупредить его, когда пользователь захочет передать какое-то событие инструменту, вместо того, чтобы принимать модель
  "запросить у пользователя команду и выполнить ее">. Джон Влиссидес пишет
  {{{http://www.research.ibm.com/designpatterns/pubs/ph-feb96.txt} колонку о C++}}, которая несет в себе хорошее объяснение
  концепции под названием "Принцип Голливуда". (Спасибо Брайану Футу and Ральфу Джонсону за помощь с этимологией).

