 ----
 Тестирование в Java. Юнит тесты.
 ----
 sody
 ----
 2011-05-16

Тестирование в Java. Юнит тесты.

* JUnit

  Самый известный, а потому и самый используемый фреймворк для тестирования. Используется в двух вариантах JUnit 4 и JUnit 3.
  Начнем с более старой версии, в старых проектах до сих пор используется, т.к. поддерживается Java 1.4.

** JUnit 3

  Для создания теста нужно унаследовать тест-класс от <<<TestCase>>>, переопределить методы <<<setUp>>> и <<<tearDown>>>
  если надо, ну и самое главное - создать тестовые методы(должны начинаться с <<<test>>>). При запуске теста сначала создается
  экземляр тест-класса, затем выполняется метод <<<setUp>>>, затем запускается сам тест, ну и в завершении выполняется метод
  <<<tearDown>>>. Если какой-либо из методов выбрасывает исключение, тест считается провалившемся.

  Примечание: тестовые методы должны быть <<<public void>>>, могут быть <<<static>>>.

  Рассмотрим пример, есть утилита для работы со строками, есть методы для проверки пустой строки и представления
  последовательности байт в виде 16-ричной строки:

+----+
public abstract class StringUtils {
  private static final int HI_BYTE_MASK = 0xf0;
  private static final int LOW_BYTE_MASK = 0x0f;

  private static final char[] HEX_SYMBOLS = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f',
  };

  public static boolean isEmpty(final CharSequence sequence) {
    return sequence == null || sequence.length() <= 0;
  }

  public static String toHexString(final byte[] data) {
    final StringBuffer builder = new StringBuffer(2 * data.length);
    for (byte item : data) {
      builder.append(HEX_SYMBOLS[(HI_BYTE_MASK & item) >>> 4]);
      builder.append(HEX_SYMBOLS[(LOW_BYTE_MASK & item)]);
    }
    return builder.toString();
  }
}
+----+

  Напишем для нее тесты используя JUnit 3. Удобнее всего на мой взгляд писать тесты рассматривая нейкий класс как черный ящик,
  писать отдельный тест на каждый значимый метод в этом классе, для каждого набора входных параметров какой-то ожидаемый
  результат. Например, тест для <<<isEmpty>>> метода:

+----+
  public void testIsEmpty() {
    boolean actual = StringUtils.isEmpty(null);
    assertTrue(actual);

    actual = StringUtils.isEmpty("");
    assertTrue(actual);

    actual = StringUtils.isEmpty(" ");
    assertFalse(actual);

    actual = StringUtils.isEmpty("some string");
    assertFalse(actual);
  }
+----+

  Можно разделить данные и логику теста, перенеся создание данных в метод <<<setUp>>>:

+----+
public class StringUtilsJUnit3Test extends TestCase {
  private final Map toHexStringData = new HashMap();

  protected void setUp() throws Exception {
    toHexStringData.put("", new byte[0]);
    toHexStringData.put("01020d112d7f", new byte[] { 1, 2, 13, 17, 45, 127 });
    toHexStringData.put("00fff21180", new byte[] { 0, -1, -14, 17, -128 });
    //...
  }

  protected void tearDown() throws Exception {
    toHexStringData.clear();
  }

  public void testToHexString() {
    for (Iterator iterator = toHexStringData.keySet().iterator(); iterator.hasNext();) {
      final String expected = (String) iterator.next();
      final byte[] testData = (byte[]) toHexStringData.get(expected);
      final String actual = StringUtils.toHexString(testData);
      assertEquals(expected, actual);
    }
  }

  //...
}
+----+

  На этом возможности фреймворка заканчиваются. Как видно из примеров все довольно просто.

* JUnit 4

  Для создания тестов можно воспользовыаться упомянутым выше способом, все рассмотреные примеры будут работать и здесь.
  Кроме этого здесь была добалена поддержка новых возможностей из Java 5. Например, тесты теперь могут быть объявлены
  с помощью аннотаций.

  Рассмотрим тот же пример, но уже используюя новые возможности:

+----+
public class StringUtilsJUnit4Test extends Assert {
  private final Map<String, byte[]> toHexStringData = new HashMap<String, byte[]>();

  @Before
  public static void setUpToHexStringData() {
    toHexStringData.put("", new byte[0]);
    toHexStringData.put("01020d112d7f", new byte[] { 1, 2, 13, 17, 45, 127 });
    toHexStringData.put("00fff21180", new byte[] { 0, -1, -14, 17, -128 });
    //...
  }

  @After
  public static void tearDownToHexStringData() {
    toHexStringData.clear();
  }

  @Test
  public void testToHexString() {
    for (Map.Entry<String, byte[]> entry : toHexStringData.entrySet()) {
      final byte[] testData = entry.getValue();
      final String expected = entry.getKey();
      final String actual = StringUtils.toHexString(testData);
      assertEquals(expected, actual);
    }
  }

  //...
}
+----+

  Итак, что мы здесь видим? Для упрощения работы я предпочитаю наследоваться от класса <<<Assert>>>, хотя это необязательно.
  Аннотация <<<@Before>>> обозначает методы, которые будут вызваны до исполнения теста, методы должны быть <<<public void>>>.
  Здесь обычно размещаются предустановки для теста, в нашем случае это генерация тестовых данных(метод
  <<<setUpToHexStringData>>>).
  Аннотация <<<@After>>> обозначает методы, которые будут вызваны после выполнения теста, методы должны быть <<<public void>>>.
  Здесь размещаются операции освобождения ресурсов после теста, в нашем случае - очистка тестовых данных(метод
  <<<tearDownToHexStringData>>>).
  Аннотация <<<@Test>>> обозначает тестовые методы, как и ранее, эти методы должны быть <<<public void>>>. Здесь размещаются
  сами проверки. Кроме того, у данной аннотации есть два параметра, <<<expected>>> - задает ожидаемое исключение и
  <<<timeout>>> - задает время после которого тест считается провалившемся.

+----+
  @Test(expected = NullPointerException.class)
  public void testToHexStringWrong() {
    StringUtils.toHexString(null);
  }

  @Test(timeout = 1000)
  public void infinity() {
    while (true);
  }
+----+

  Итак, теперь методы <<<setUpToHexStringData>>> и <<<tearDownToHexStringData>>> вызываются постоянно и для каждого теста,
  но что если это нужно сделать только 1 раз? В этом случае можно воспользоваться <<<@BeforeClass>>> и <<<@AfterClass>>>
  аннотациями. Они должны быть <<<public static void>>> и будут вызваны до создания экземпляра тест-класса,
  т.о. генерация данных будет происходить только однажды.

+----+
  @BeforeClass
  public static void setUpToHexStringData() {
    //...
  }

  @AfterClass
  public static void tearDownToHexStringData() {
    //...
  }
+----+

  Если какой-либо тест по какой-либо серьезной причине нужно отключить(например, этот тест постоянно валится,
  но его исправление отложено до светлого будущего) его можно зааннотировать <<<@Ignore>>>. Также если поместить эту аннотацию
  на класс, то все тесты в этом классе будут отключены.

+----+
  @Ignore
  @Test(timeout = 1000)
  public void infinity() {
    while (true);
  }
+----+

  Но и на этом возможности фреймворка не заканчиваются. Кроме всего вышеперечисленного здесь есть довольно интересная вешь -
  правила. Правила это некое подобие утилит для тестов, которые добавляют функционал до и после выполнения теста.
  Например есть встроеные правила для задания таймаута для теста(<<<Timeout>>>), для задания ожидаемых
  исключений(<<<ExpectedException>>>), для работы с временными файлами(<<<TemporaryFolder>>>) и д.р.
  Для объявления правила необходимо создать <<<public>>> не <<<static>>> поле типа производного от <<<MethodRule>>> и
  зааннотировать его с помощью <<<@Rule>>>.

+----+
public class OtherJUnit4Test {

  @Rule
  public final TemporaryFolder folder = new TemporaryFolder();

  @Rule
  public final Timeout timeout = new Timeout(1000);

  @Rule
  public final ExpectedException thrown = ExpectedException.none();

  @Ignore
  @Test
  public void anotherInfinity() {
    while (true);
  }

  @Test
  public void testFileWriting() throws IOException {
    final File log = folder.newFile("debug.log");
    final FileWriter logWriter = new FileWriter(log);
    logWriter.append("Hello, ");
    logWriter.append("World!!!");
    logWriter.flush();
    logWriter.close();
  }

  @Test
  public void testExpectedException() throws IOException {
    thrown.expect(NullPointerException.class);
    StringUtils.toHexString(null);
  }
}
+----+

* TestNG

* Spock Framework
